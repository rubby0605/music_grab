#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Discord Bot：YouTube URL → 鋼琴樂譜 PDF
Pipeline: yt-dlp → basic-pitch (MIDI) → pretty_midi → LilyPond → PDF
"""

import os
import re
import tempfile
import asyncio
import shutil
import subprocess
import discord
import pretty_midi

DISCORD_TOKEN = os.environ.get('DISCORD_BOT_TOKEN', '')
DISCORD_MAX_BYTES = 25 * 1024 * 1024
YT_URL_PATTERN = re.compile(
    r'(https?://)?(www\.)?(youtube\.com/watch\?v=|youtu\.be/|youtube\.com/shorts/)[\w\-]+'
)

intents = discord.Intents.default()
intents.message_content = True
client = discord.Client(intents=intents)


def download_audio(url, tmpdir):
    """用 yt-dlp 下載 YouTube 音頻為 wav"""
    output_path = os.path.join(tmpdir, 'audio.%(ext)s')
    cmd = [
        'yt-dlp', '-x', '--audio-format', 'wav',
        '--audio-quality', '0',
        '-o', output_path,
        '--no-playlist',
        url
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
    if result.returncode != 0:
        raise RuntimeError(f'yt-dlp 失敗: {result.stderr[-300:]}')

    wav_path = os.path.join(tmpdir, 'audio.wav')
    if not os.path.exists(wav_path):
        # 有時 yt-dlp 會用其他副檔名
        for f in os.listdir(tmpdir):
            if f.startswith('audio.'):
                wav_path = os.path.join(tmpdir, f)
                break
    return wav_path


def get_video_title(url):
    """取得影片標題"""
    try:
        result = subprocess.run(
            ['yt-dlp', '--get-title', '--no-playlist', url],
            capture_output=True, text=True, timeout=30
        )
        return result.stdout.strip()[:60] or 'Untitled'
    except Exception:
        return 'Untitled'


def audio_to_midi(wav_path, tmpdir):
    """用 basic-pitch CLI 轉換音頻為 MIDI"""
    cmd = [
        'basic-pitch', tmpdir, wav_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
    if result.returncode != 0:
        raise RuntimeError(f'basic-pitch 失敗: {result.stderr[-300:]}')

    # basic-pitch 輸出 MIDI 檔名為 audio_basic_pitch.mid
    for f in os.listdir(tmpdir):
        if f.endswith('.mid') or f.endswith('.midi'):
            return os.path.join(tmpdir, f)
    raise RuntimeError('basic-pitch 未產出 MIDI 檔')


def midi_to_lilypond(midi_path, ly_path, title='Piano'):
    """將 MIDI 轉成 LilyPond 格式"""
    midi = pretty_midi.PrettyMIDI(midi_path)

    # 取得所有音符
    all_notes = []
    for inst in midi.instruments:
        if not inst.is_drum:
            all_notes.extend(inst.notes)

    if not all_notes:
        raise RuntimeError('MIDI 中沒有音符')

    all_notes.sort(key=lambda n: n.start)

    # 限制最多處理前 500 個音符（避免 PDF 過大）
    notes = all_notes[:500]

    # 取得 tempo
    tempo_times, tempos = midi.get_tempo_changes()
    bpm = int(tempos[0]) if len(tempos) > 0 else 120

    # 音符名稱對照
    NOTE_NAMES = ['c', 'cis', 'd', 'dis', 'e', 'f', 'fis', 'g', 'gis', 'a', 'ais', 'b']

    def pitch_to_lily(midi_pitch):
        octave = (midi_pitch // 12) - 1
        note_name = NOTE_NAMES[midi_pitch % 12]
        # LilyPond: c' = middle C (MIDI 60, octave 4)
        lily_octave = octave - 3
        if lily_octave > 0:
            note_name += "'" * lily_octave
        elif lily_octave < 0:
            note_name += "," * abs(lily_octave)
        return note_name

    def duration_to_lily(dur_sec, bpm):
        beat_sec = 60.0 / bpm
        beats = dur_sec / beat_sec
        if beats >= 3.5:
            return '1'
        elif beats >= 1.75:
            return '2'
        elif beats >= 0.875:
            return '4'
        elif beats >= 0.4375:
            return '8'
        elif beats >= 0.21875:
            return '16'
        else:
            return '32'

    # 分左右手 (以 MIDI 60 = middle C 分界)
    right_hand = [n for n in notes if n.pitch >= 60]
    left_hand = [n for n in notes if n.pitch < 60]

    def notes_to_lily_str(note_list):
        if not note_list:
            return 'r1 r1 r1 r1'
        parts = []
        for n in note_list:
            dur = n.end - n.start
            lily_note = pitch_to_lily(n.pitch)
            lily_dur = duration_to_lily(dur, bpm)
            parts.append(f'{lily_note}{lily_dur}')
        return ' '.join(parts)

    right_str = notes_to_lily_str(right_hand)
    left_str = notes_to_lily_str(left_hand)

    # 清理標題中的特殊字元
    safe_title = re.sub(r'[\\\"{}]', '', title)

    ly_content = f'''\\version "2.24.0"
\\header {{
  title = "{safe_title}"
  subtitle = "Auto-transcribed from YouTube"
  tagline = "Generated by Discord Sheet Music Bot"
}}

\\score {{
  \\new PianoStaff <<
    \\new Staff = "right" {{
      \\clef treble
      \\tempo 4 = {bpm}
      {{ {right_str} }}
    }}
    \\new Staff = "left" {{
      \\clef bass
      {{ {left_str} }}
    }}
  >>
  \\layout {{ }}
}}
'''

    with open(ly_path, 'w') as f:
        f.write(ly_content)


def lilypond_to_pdf(ly_path, tmpdir):
    """用 LilyPond 編譯 .ly → .pdf"""
    cmd = ['lilypond', '-dno-point-and-click', '-o', os.path.join(tmpdir, 'score'), ly_path]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
    pdf_path = os.path.join(tmpdir, 'score.pdf')
    if not os.path.exists(pdf_path):
        raise RuntimeError(f'LilyPond 編譯失敗: {result.stderr[-500:]}')
    return pdf_path


def full_pipeline(url, tmpdir):
    """完整 pipeline: YouTube → PDF"""
    title = get_video_title(url)
    print(f'  Title: {title}')

    print('  Downloading audio...')
    wav_path = download_audio(url, tmpdir)
    print(f'  Audio: {wav_path}')

    print('  Transcribing to MIDI...')
    midi_path = audio_to_midi(wav_path, tmpdir)
    print(f'  MIDI: {midi_path}')

    print('  Converting to LilyPond...')
    ly_path = os.path.join(tmpdir, 'score.ly')
    midi_to_lilypond(midi_path, ly_path, title=title)

    print('  Compiling PDF...')
    pdf_path = lilypond_to_pdf(ly_path, tmpdir)
    print(f'  PDF: {pdf_path}')

    return pdf_path, midi_path, title


@client.event
async def on_ready():
    print(f'Sheet Music Bot 已上線: {client.user}')


@client.event
async def on_message(message):
    if message.author == client.user or message.author.bot:
        return

    content = message.content.strip()

    # 偵測 YouTube URL
    match = YT_URL_PATTERN.search(content)
    if not match:
        return

    url = match.group(0)
    if not url.startswith('http'):
        url = 'https://' + url

    await message.channel.send(f'收到 YouTube 連結，開始轉換鋼琴樂譜...\n`{url}`')

    tmpdir = tempfile.mkdtemp()
    try:
        loop = asyncio.get_event_loop()

        await message.channel.send('1/4 下載音頻中...')
        pdf_path, midi_path, title = await loop.run_in_executor(
            None, full_pipeline, url, tmpdir
        )

        safe_title = re.sub(r'[^\w\s\-]', '', title)[:40] or 'score'

        # 傳送 PDF
        pdf_size = os.path.getsize(pdf_path)
        if pdf_size <= DISCORD_MAX_BYTES:
            await message.channel.send(
                content=f'**{title}** 的鋼琴樂譜：',
                file=discord.File(pdf_path, filename=f'{safe_title}.pdf')
            )
        else:
            await message.channel.send(f'PDF 太大了（{pdf_size/(1024*1024):.1f} MB）')

        # 也傳送 MIDI 檔
        midi_size = os.path.getsize(midi_path)
        if midi_size <= DISCORD_MAX_BYTES:
            await message.channel.send(
                content='MIDI 檔案（可匯入 DAW 或 MuseScore 編輯）：',
                file=discord.File(midi_path, filename=f'{safe_title}.mid')
            )

        await message.channel.send('轉換完成！')

    except Exception as e:
        await message.channel.send(f'轉換失敗：{e}')
    finally:
        shutil.rmtree(tmpdir, ignore_errors=True)


if __name__ == '__main__':
    if not DISCORD_TOKEN:
        print('請設定環境變數 DISCORD_BOT_TOKEN')
        exit(1)
    client.run(DISCORD_TOKEN)
